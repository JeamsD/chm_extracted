<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html xmlns:innovasys xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
    <meta content="history" name="save" />
    <meta name="GENERATOR" content="Innovasys HelpStudio (http://www.innovasys.com)" />
    <title>Search Syntax</title>
    <link rel="stylesheet" type="text/css" href="stylesheets/helpstudio.css" />
    
    
    <link rel="stylesheet" type="text/css" href="stylesheets/hs-boxes.css"></link>
    <link rel="stylesheet" type="text/css" href="stylesheets/hs-expandcollapse.css"></link>
    <link rel="stylesheet" type="text/css" href="stylesheets/hs-simpletab.css"></link>
    <link rel="stylesheet" type="text/css" href="stylesheets/hs-heading-expandcollapse.css"></link>
    <link rel="stylesheet" type="text/css" href="stylesheets/hs-tabstrip.css"></link>
    <link rel="stylesheet" type="text/css" href="ApiHelp.css"></link>
    <script src="script/helpstudio.js" type="text/javascript"></script>
    
    <script src="script/hs-expandcollapse.js" type="text/javascript"></script>
    <script src="script/hs-enlargeimage.js" type="text/javascript"></script>
    <script src="script/swfobject.js" type="text/javascript"></script>
    <script src="script/hs-common.js" type="text/javascript"></script>
    <script src="script/hs-heading-expandcollapse.js" type="text/javascript"></script>
    <script src="script/hs-tabstrip.js" type="text/javascript"></script>
    <style type=text/css>div#pagetop, div#pagetop table td, span#projecttitle, span#pagetitle {background-color: #CCCCFF}</style>
    
	
    
    
</head>
<body id="hsbody">
	
    <div style="display: none">
        <input type="hidden" id="userDataCache" class="userDataStyle" name="userDataCache" />
        <input type="hidden" id="hiddenScrollOffset" name="hiddenScrollOffset" />
    </div>
    <img id="collapseImage" style="display:none; height:0; width:0;" src="images/collapse.gif">
    <img id="expandImage" style="display:none; height:0; width:0;" src="images/expand.gif"/>
    <img id="copyImage" style="display:none; height:0; width:0;" src="images/copycode.gif"/>
    <img id="copyHoverImage" style="display:none; height:0; width:0;" src="images/copycodeHighlight.gif">
    <img id="dropDownImage" style="display:none; height:0; width:0;" src="images/drpdown.gif"/>
    <img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="images/drpdown_orange.gif"/>
    <div id="pagetop">
        
        <table width="100%" id="pagetoptable2" cellspacing="0" cellpadding="0">
        	<tr>
        		<td></td>
        	</tr>
        </table>
        <table width="100%" id="pagetoptable1">
            <tr id="pagetoptable1row1">
                <td align="left">
                    <span id="projecttitle">
                        SOLIDWORKS PDM Professional API Help
                    </span>
                </td>
                <td align="right" rowspan="2">
                    
                </td>
            </tr>
            <tr id="pagetoptable1row2">
                <td align="left">
                    <span id="pagetitle">
                        Search Syntax
                    </span>
                </td>
            </tr>
            <tr id="pagetoptable1row3">
            	<td colspan="2">
            		
            		<span id="feedbacklink"><a href="mailto:apihelp.feedback@3ds.com?subject=Documentation Feedback: SearchSyntax-epdmapi.html">Send Feedback</a></span>
            	</td>
            </tr>
        </table>
        
        
    </div>
    <div class="hspopupbubble" id="hsglossaryitembox">
        <p>Glossary Item Box</p>
    </div>
    <div id="pagebody">
        <div id="mainbody">
<P><A id=top name=top></A>Before now&nbsp;you searched for documents in the&nbsp;vault using&nbsp;text, comparison operators, and wildcards. As of SOLIDWORKS PDM Professional 2020, you can search using a richer syntax set. To do this, create a new search object using&nbsp;<A href="EPDM.Interop.epdm~EPDM.Interop.epdm.IEdmVault21~CreateSearch2.html">IEdmVault21::CreateSearch2</A>. The new search object gives all IEdmSearch* properties and method parameters the enhanced search syntax capability outlined below.</P>
<H4><A href="#Summary">Summary of Syntax Kernel Logic</A></H4>
<H4>Basic Syntax - Details</H4>
<UL>
<LI class=kadov-p><A href="#Syntax">Syntax expressions</A> 
<LI class=kadov-p><A href="#Patterns">Patterns (Variable, Search, and Complex)</A> 
<LI class=kadov-p><A href="#Encapsulated">Encapsulated expressions and complex patterns</A> 
<LI class=kadov-p><A href="#Comparisons">Patterns and comparisons</A> 
<LI class=kadov-p><A href="#DataTypes">Explicit/implicit data types</A> 
<LI class=kadov-p><A href="#Colon">Colon-attached specifiers</A></LI></UL>
<H4>Advanced Syntax - Details</H4>
<UL>
<LI class=kadov-p><A href="#Advanced">Advanced specifiers</A> 
<LI class=kadov-p><A href="#multi-value">Multi-value specifiers</A> 
<LI class=kadov-p><A href="#Bindings">Variable (@) and configuration (@@) bindings</A> 
<LI class=kadov-p><A href="#Colon2">Colon-attached bindings</A></LI></UL>
<H4>Examples</H4>
<UL>
<LI class=kadov-p><A href="Using_Basic_Search_Syntax_Example_VBNET.htm">Using Basic Search Syntax (VB.NET)</A> 
<LI class=kadov-p><A href="Using_Basic_Search_Syntax_Example_CSharp.htm">Using Basic Search Syntax (C#)</A></LI></UL>
<P>&nbsp;</P>
<H6><A id=Summary name=Summary></A>Summary of Syntax Kernel Logic</H6>
<H4>A. The basic rules - preparing variable names and search values</H4>
<UL>
<LI>Comparison operators: =, &lt;, &gt;, &lt;&gt;, &lt;=, &gt;=. 
<LI>Contains patterns (P) and comparisons (&lt;= Q) can be combined&nbsp;using logical operators AND (&amp;), OR (|) and NOT (!) and parentheses (). 
<LI>Negated comparisons are similar to negated simple patterns. For example, !=P is the same as !{=P}. &lt;&gt;P is the same as {!=P} and (&lt; P | &gt; P). 
<LI>Spaces may be used to divide operands and operators for readability. 
<LI>AND is implicit in patterns. For example, (P Q R) means P &amp; Q &amp; R. 
<LI>The order of logical operator processing is NOT, AND, OR.&nbsp; 
<LI>To search for spaces and special characters, quote them&nbsp;with " or escape them&nbsp;with \. 
<LI>A quotation mark inside a&nbsp;pattern is not interpreted. To&nbsp;recognize ",&nbsp;escape it&nbsp;with \.&nbsp; 
<LI>A backslash inside a&nbsp;pattern must also be escaped with \. 
<LI>\ escapes both inside and outside of quotations.&nbsp;&nbsp; 
<LI>* and ?&nbsp;are wildcards both inside and outside of quotations, but only in the context of Contains or !Contains. 
<LI>\ is not required before * and ? in variable/configuration names or with comparison operators. 
<LI>Numeric constants are compared as numbers only if the variable&nbsp;has a&nbsp;numeric data type. 
<LI>Correctly represented dates (as quoted or unquoted strings) are compared as dates only if the variable has the DATE data type.</LI></UL>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4>B. Patterns and comparisons (explicit and implicit data types)</H4>
<UL>
<LI>Single-value search logic is the default search logic. All conditions are implicitly contained in {} (see&nbsp;<A href="#Encapsulated">Encapsulated expressions and complex patterns</A>). You can use braces, but they do not change the underlying logic. In single-value search logic, condtions target single variables/condigurations. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>A &amp; B</STRONG> and <STRONG>{A B}</STRONG> both find documents containing variable values that contain both A and B</P>
<UL>
<LI><STRONG>: !P</STRONG> finds documents even if they have no&nbsp;variable values. 
<LI><STRONG>{!P}</STRONG> only&nbsp;finds documents with&nbsp;existing variable values. 
<LI><STRONG>: !P or !{...}</STRONG> finds all those documents that aren't found by P (or {...})&nbsp; 
<LI>Patterns can be negated indirectly. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>!(!P | Q) is the same as P &amp; !Q</STRONG></P>
<UL>
<LI>Comparisons (including =, &lt; , ...), even combined with AND/OR, always work over a single value, whether negated or not (directly or indirectly).&nbsp; 
<LI>Data type specifiers (TEXT, INT, ...) explicitly set how patterns should be compared. 
<LI>TEXT&nbsp;and the other data types have&nbsp;the same priority as NOT. For example,&nbsp;in condition INT A B, INT&nbsp;operates only on&nbsp;A. To extend&nbsp;the scope of INT, INT(A &amp; B) should be used. 
<LI>The common data type of a multi-variable field is detected implicitly:</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If texts are mixed with non-texts, then&nbsp;the data type&nbsp;is TEXT.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If dates are mixed with non-dates, then it is TEXT.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If integers are mixed with floats, then it&nbsp;is FLOAT.</P>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4>C. Variables (@) and configurations (@@)</H4>
<UL>
<LI>@ introduces a variable, e.g.,&nbsp;@Comment, @"Document number". Quotation/escaping is needed in case of spaces or special characters. Case is not detected. 
<LI>@ can also be used with a numeric constant representing a variable ID. 
<LI>@&nbsp;can also be&nbsp;a binder that binds a certain variable to a syntax&nbsp;expression that follows. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@Author!=Pete</STRONG></P>
<UL>
<LI>A binding can be multi-variable&nbsp;(like @(...)) with several variables inside that are delimited by&nbsp;OR (|). For example, &nbsp;</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@(Author | Creator) != Pete</STRONG>&nbsp;</P>
<UL>
<LI>"" or 0 represents a multiple "variable" that includes all common variables in the database. It corresponds to &lt;Any Variable&gt; in tab Variables.&nbsp; 
<LI>_Name is a special "variable" which corresponds to the file/folder name criterion.&nbsp; 
<LI>A binding has the same priority as NOT, !, TEXT, DATE, etc. For example,&nbsp;</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In <STRONG>@Version P Q</STRONG>, Version must contain P,&nbsp;and Q&nbsp;must be&nbsp;found in&nbsp;another variable specified in the attached variable list.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In <STRONG>@Variable1 (@Variable2 P &amp; Q),</STRONG> P must be found in Variable2 and Q must be found in Variable1.</P>
<UL>
<LI><STRONG>@Var1 @Var2 P</STRONG> results in a syntax error. To set multiple variables, use <STRONG>@(Var1|Var2) P</STRONG>. 
<LI>Parentheses can change the binding's operation, e.g.,&nbsp;<STRONG>@Version(P Q)</STRONG> means Version must contain both P and Q.</LI></UL>
<UL>
<LI>Bindings are directly applied to positive patterns in a distributive fashion&nbsp;(either simple&nbsp;(P), or complex { ... }). For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@Number(!P &amp;{ Q | R })</STRONG> is the same as <STRONG>!@Number(P) &amp; @Number{Q | R}</STRONG></P>
<UL>
<LI>@ is not allowed inside encapsulation braces&nbsp;{ ... }.&nbsp;</LI></UL>
<UL>
<LI>In addition to | , variables can be combined with AND (&amp;), NOT (!), and parentheses. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@("" &amp; !Comment) P</STRONG> means at least one of the database variables, but not Comment, contains P.&nbsp;</P>
<UL>
<LI>@@ introduces configurations in the same way&nbsp;that @ introduces variables. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@@"@" P</STRONG> means search only the default configuration ("@")&nbsp;to find P.</P>
<UL>
<LI>"" or 0 represents a multiple "configuration" which includes all configurations from the database.&nbsp; 
<LI>Default configuration is "@". 
<LI>Configuration 1 has a predefined name " " (a single space), no matter what its name is in the database.&nbsp; 
<LI>@() and @@() represent the initial setting of variables / configurations. 
<LI>@() means no variables (as initially in tab Variables). 
<LI>@@() means the same as @@"" or @@0. By default all configurations are searched.</LI></UL>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4>D. Colon-attached (:) specifiers and variables</H4>
<UL>
<LI>Some keywords and operators at the beginning of (sub)-formula can&nbsp;have a colon attached, e.g., AND:, OR:, NOT:, &amp;:, |:, !:, TEXT:, INT:, FLOAT:, DATE:. Such specifiers have the lowest priority and are processed after (), {}, NOT, AND, OR. For example,</LI></UL>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<STRONG>TEXT: a | b</STRONG> is the same as <STRONG>TEXT(a | b)</STRONG></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<STRONG>(TEXT: a) &amp; (INT: 1)</STRONG> is the same as <STRONG>TEXT a INT 1</STRONG></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<STRONG>NOT: a b</STRONG> is the same as <STRONG>NOT(a b)</STRONG></P>
<UL>
<LI>OR: implicitly sets spaces as ORs inside a given (sub-)formula. 
<LI>AND: implicitly sets spaces as ANDs inside a given (sub-)formula. 
<LI>You can use a colon in place of @ for variable binding. Instead of <STRONG>@(Author|Comment|_Name|52) (john|smith)</STRONG> you can use <STRONG>Author:Comment:_Name:52: john|smith</STRONG>. 
<LI>You can use two colons in place of @@ for configuration binding. For example, <STRONG>"@":: 1:: 3:: john|smith.</STRONG></LI></UL>
<H4>E. The advanced and multi-value specifiers (@: and :)</H4>
<UL>
<LI>The basic search syntax can be restrictive (i.e., no variable/configuration binding, no syntax error reporting, no explicit variable/config names/ids in conditions). 
<LI>&nbsp;@: placed at the beginning of a&nbsp;condition permits: 
<UL>
<LI>Variable/configuration binding, including the colon-attached format. For example, <STRONG>@:Comment:city</STRONG> finds documents where Comment contains city. 
<LI>Multi-value search logic in which conditions target multiple variables/configurations. Braces are needed to specify single-value complex patterns. 
<LI>Syntax error reporting. 
<LI>Using _Name&nbsp;to represent a file/folder name. 
<LI>Using virtual variables, including "" and 0 which represent all variables or configurations.</LI></UL>
<LI>: (colon) placed at the beginning of a condition permits: 
<UL>
<LI>Multi-value search logic in which conditions target multiple variables/configurations. Braces are needed to specify local&nbsp;single-value complex patterns within the multi-value condition.</LI></UL></LI></UL>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H6>Basic Syntax - Details</H6>
<H4><A id=Syntax name=Syntax></A>Syntax expressions</H4>
<P class=MsoNormal>Syntax expressions&nbsp;and patterns are the new search values. The former search value <STRONG>Metal</STRONG> is exactly the same as the new corresponding pattern <STRONG>Metal</STRONG>. Syntax expressions include conditions with logical operators AND/OR/NOT or their shortcuts &amp; | !. For example, <STRONG>Ferrous &amp; Metal</STRONG> means a document should contain both substrings, <STRONG>Metal</STRONG> and <STRONG>Ferrous</STRONG>.</P>
<P class=MsoNormal>Single-value search logic is the default search logic. In single-value search logic conditions target single variables/configurations. Documents that contain a variable/configuration which satisfies the single-value complex pattern&nbsp;are found. Any condition that is passed as a second argument to&nbsp;<A href="EPDM.Interop.epdm~EPDM.Interop.epdm.IEdmSearch8~AddVariable2.html">IEdmSearch8::AddVariable2</A> or&nbsp;<A href="EPDM.Interop.epdm~EPDM.Interop.epdm.IEdmSearch9~AddMultiVariableCondition.html">IEdmSearch9::AddMultiVariableCondition</A> is also implicitly enclosed in {} and is processed as a single-value complex pattern. (For multi-value search logic, see the <STRONG>Advanced Syntax - Details</STRONG>&nbsp;section.)</P>
<P class=MsoNormal>The logical AND can be applied implicitly by omitting AND (&amp;). For example, <STRONG>Ferrous Metal</STRONG>. However, the old search value, <STRONG>Ferrous Metal</STRONG>, meant an exact phrase to be searched inside a variable value. According to the new rules, you should apply quotation marks to set&nbsp;the exact phrase, <STRONG>"Ferrous Metal"</STRONG>. The quotation marks are auxiliary here - they don't belong to the searched text itself. This is similar to Google Search where <STRONG>Metal</STRONG> and <STRONG>Ferrous</STRONG> can be found in different places of the document, in any order, in any number of instances, and so on. If we want to search&nbsp;for the&nbsp;phrase <STRONG>Ferrous Metal</STRONG> in Google Search<STRONG>,</STRONG>&nbsp;then we must quote it. The same is now true with SOLIDWORKS PDM Pro 2020.</P>
<P class=MsoNormal>If a quotation mark itself belongs to the searched text, then it has to be preceded by an auxiliary backslash. For example,&nbsp;<STRONG>\"</STRONG>. Each searched backslash has to be also preceded by another backslash - the first is an auxiliary one, the second is an actual character. In fact, any character can be escaped in that way. Special characters like &amp;, | and others cannot be searched directly: A&amp;B means "A" AND "B" but not "A&amp;B". So they should be either quoted or escaped, or both, if searched, e.g. <STRONG>"A&amp;B"</STRONG> or <STRONG>A\&amp;B</STRONG> or <STRONG>"A\&amp;B"</STRONG>.</P>
<P class=MsoNormal>You can avoid using quotes in favor of escaping. For example, <STRONG>Ferrous\ Metal</STRONG> (the space is escaped). On the contrary,&nbsp;you can always use auxiliary quotes, even if they are not really needed. For example,&nbsp;<STRONG>"Metal".</STRONG></P>
<P class=MsoNormal>When quoting, the searched text should be between the beginning and the ending quote, so "" means an empty string. Quoted and unquoted pieces cannot be attached to each other. For example,&nbsp;<STRONG>"("abc")"</STRONG> is incorrect.</P>
<P class=MsoNormal>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4><A id=Patterns name=Patterns></A>Patterns (Variable, Search, and Complex types)</H4>
<P class=MsoNormal>A pattern is any quoted or unquoted searched (as a whole unit) text. For example, <STRONG>Ferrous Metal</STRONG> contains two patterns, and <STRONG>"Ferrous Metal"</STRONG> is a single one.</P>
<P class=MsoNormal>A pattern is a syntax expression that represents a searched value or a variable/configuration name or ID. Though we sometimes say&nbsp;"Document number"&nbsp;is a variable name,&nbsp;that is&nbsp;not correct. The variable name is actually <STRONG>Document number</STRONG>. It is quoted, "Document number", to represent the variable name. We can represent the variable name in different ways, e.g. Document\ number.</P>
<P class=MsoNormal>Simple names (or searched values) can be identical to their representations: <STRONG>Author</STRONG>, <STRONG>Comment</STRONG>, etc. However, even simple names can be represented by different patterns:&nbsp; <STRONG>Author</STRONG>, <STRONG>"Author"</STRONG>, <STRONG>\Author</STRONG>, <STRONG>Au\thor</STRONG>, <STRONG>"\Author"</STRONG> represent the same name, <STRONG>Author</STRONG>. <STRONG>Document number</STRONG> cannot be identical to its representation because of&nbsp;the space inside its name.</P>
<P class=MsoNormal>When&nbsp;talking about variables and configurations, numeric constants are database IDs. If a variable name in the database is identical to a numeric constant (i.e., constituted of digits), then you should use quotation marks or backslashes in its representation to&nbsp;differentiate it&nbsp;from numeric constants, i.e.,&nbsp;<STRONG>"51"</STRONG>, <STRONG>\82</STRONG>. If a name in the database begins with _, it must also to be represented&nbsp;using " or \ because initial-underscored names are reserved for syntax usage.</P>
<P class=MsoNormal>Patterns may require another set of quotes&nbsp;as are required&nbsp;in C# or VB applications to escape their own reserved characters.</P>
<P class=MsoNormal>Spaces can be used or not between patterns and comparison/logical signs and parentheses to improve readability.</P>
<P class=MsoNormal>Without a comparison sign, any pattern is interpreted in the context of "Contains". In such cases, * and ? (if not escaped) work as wildcards "any number of characters" and "a single arbitrary character", e.g. "(*)" means a variable value should begin with "(" and end with ")". If no explicit non-escaped wildcards, they are meant implicitly. For example, <STRONG>Metal</STRONG> is equivalent to <STRONG>*Metal*</STRONG> (if no comparison sign, of course). Due to the explicit wildcard, "(*)" represents the whole variable value, not a substring inside it.</P>
<P class=MsoNormal>When talking about searched values (i.e. not about variable/configuration names), patterns can include wildcards, but only in the context of Contains, i.e. without =, &lt;, &gt;, etc. A pattern with wildcards represents a multitude of values. Again different patterns with wildcards can be equivalent to one other, even without " and \. For example, <STRONG>a*z</STRONG> represents the same set of values as <STRONG>a**z</STRONG>. Of course, \ and " give other equivalent representations: <STRONG>"a**z"</STRONG>, <STRONG>\a*z</STRONG>, <STRONG>"a*\z",</STRONG> etc.&nbsp;Note, you&nbsp;cannot use \ before wildcards if they are expected to work as wildcards. For example,&nbsp;<STRONG>a\*z</STRONG> represents exactly one word of three characters: a, *, and z.&nbsp;A backslash (\)&nbsp;before * and ? makes them common characters, no matter in what context. \ is not required before * and ? in variable/configuration names or with =, &lt;, &gt;, etc.</P>
<P class=MsoNormal>A complex pattern is any expression of the kind of {...}. Variables and configurations cannot be represented by complex patterns, and comparison operators cannot stand before them. Complex patterns are always considered in the context of Contains. For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>{a* &amp; *z}</STRONG> is interpreted as <STRONG>"Contains a value that satisfies the condition inside {...}"</STRONG></P>
<P class=MsoNormal>It's clear that a complex pattern <STRONG>{a* &amp; *z}</STRONG> and a simple one <STRONG>a*z</STRONG> can both represent the same set of searched values.</P>
<P class=MsoNormal>It's easy to find examples where a pattern is equivalent to a non-pattern: <STRONG>Ferrous</STRONG> is equivalent to <STRONG>(Ferrous)</STRONG> and to <STRONG>{Ferrous}</STRONG>, and to <STRONG>(Ferrous &amp; Ferrous)</STRONG>, and to <STRONG>!!Ferrous</STRONG>.</P>
<P class=MsoNormal>Positive patterns only work over existing document values. If a document contains a value that satisfies the given pattern, then the document is found. Any encapsulated complex sub-condition {...} is also a positive pattern.&nbsp;<STRONG>{!P}</STRONG>, being a positive complex pattern, only works on existing values. If one value/configuration of the document contains P but another one does not, the document&nbsp;is found. If a pattern is in the scope of a single variable and a single configuration, then <STRONG>{!P} AND P</STRONG> cannot be satisfied. If several variable/configurations are inolved, <STRONG>:{!P} &amp; P</STRONG> may find some documents.</P>
<P class=MsoNormal>Negative patterns are patterns that are under negation. For example, <STRONG>!Metal</STRONG>. Negation can be indirect. For example, <STRONG>!(A !B)</STRONG> means that A is negated and B is not negated. Negative patterns find all those documents that are not found by corresponding positive patterns.</P>
<P class=MsoNormal>For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <STRONG>!P</STRONG> yields every document that doesn't contain P in any of its variables/configurations. It may find documents that don't have any values at all, because emptiness also does not contain P.</P>
<P class=MsoNormal><STRONG>&nbsp;&nbsp;&nbsp;&nbsp; {!P}</STRONG>, being a positive complex pattern, only works on existing values.</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>!{!P}</STRONG> returns all documents where each existing value contains P, including those documents without values.</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>P &amp; !P</STRONG> returns no documents.</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <STRONG>P | !P</STRONG>&nbsp;returns all documents.&nbsp;&nbsp;</P>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4><A id=Encapsulated name=Encapsulated></A>Encapsulated expressions and complex patterns</H4>
<P>A complex pattern is any expression of the kind of {...}. Variables and configurations cannot be represented by complex patterns, and comparison operators cannot appear before them. Complex patterns are always considered in the context of Contains. For example,</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>{a* &amp; *z}</STRONG> is interpreted as <STRONG>"Contains a value that satisfies the condition inside {...}"</STRONG></P>
<P>It's clear that a complex pattern <STRONG>{a* &amp; *z}</STRONG> and a simple pattern <STRONG>(a*z)</STRONG> can both represent the same set of searched values.</P>
<P class=MsoNormal>Braces ({}) show that the whole sub-formula inside them should be searched for within a single variable value (for a given combination of variable and configuration). <STRONG>{Metal Ferrous}</STRONG> means that both substrings <STRONG>Metal</STRONG> and Ferrous <STRONG>should</STRONG> belong to the same variable value in the same configuration (in any order, in any places, and in any number of instances). Without braces, <STRONG>Ferrous</STRONG> can be found in one variable (or configuration) and <STRONG>Metal</STRONG> in a different variable (of the same document, of course).</P>
<P class=MsoNormal>Encapsulated expressions {...} can be considered complex patterns. You can write <STRONG>a*b</STRONG> or <STRONG>{a* &amp; *b}.</STRONG> Both mean the same and both are checked inside the same single value.</P>
<P class=MsoNormal><STRONG>{!=100}</STRONG> only finds a document that has a certain value not equal to 100, though some other value can be equal to 100. <STRONG>&lt;&gt;100</STRONG> works the same as <STRONG>{!=100}</STRONG>.&nbsp;<STRONG>!{=100}</STRONG>&nbsp;or just <STRONG>!=100</STRONG> only finds those documents that don't have any values equal to 100 (multi-value context).</P>
<P class=MsoNormal>Basic search syntax&nbsp;employs single-value search logic that implicitly encapsulates conditions in braces. You can use braces, but they do not change the underlying logic.</P>
<P class=MsoNormal>Advanced search syntax employs multi-value search logic that does not implicitly encapsulate conditions&nbsp;in braces. You must use braces to specify complex patterns. (See the <STRONG>Advanced Syntax- Details</STRONG> section.)</P>
<P class=MsoNormal>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4><A id=Comparisons name=Comparisons></A>Patterns and comparisons</H4>
<P class=MsoNormal>A comparison is a combination of a sign like =, &lt;, &gt;= etc. and a pattern like&nbsp;<STRONG>=Ferrous</STRONG>.</P>
<P class=MsoNormal>Patterns and comparisons are simple operands (i.e. terms) that can be combined with AND, OR, NOT. To set the logical order, use parentheses: (sldptr | txt) &amp; attachment. Without parentheses, NOT has the highest priority and&nbsp;OR has the lowest.</P>
<P class=MsoNormal>Spaces can be used or not between patterns and comparison/logical signs and parentheses to improve readability.</P>
<P class=MsoNormal>Without a comparison sign, any pattern is interpreted in the context of "Contains". In that case, * and ? (if not escaped) work as wildcards (* = "any number of characters" and ? = "a single arbitrary character"). For example,&nbsp;"(*)" means a variable value should begin with "(" and end with ")". If no explicit non-escaped wildcards, they are meant implicitly. For example,&nbsp;<STRONG>Metal</STRONG> is equivalent to <STRONG>*Metal*</STRONG> (if no comparison sign, of course). Due to the explicit wildcard, <STRONG>"(*)"</STRONG> represents the whole variable value, not a substring inside it.</P>
<P class=MsoNormal>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4><A id=DataTypes name=DataTypes></A>Explicit/implicit data types</H4>
<P class=MsoNormal>Expressions are processed under a certain data type that has been inherited from the field variable. You can explicitly set a different data type. For example, in&nbsp;<STRONG>DATE &gt;="Jan 15, 2005"</STRONG> , "Jan 15, 2005" will be considered a date type, not a string type. In the DATE context, patterns will be compared as texts if they don't represent correct dates. A correct date representation can be quoted or have escaped characters.&nbsp;</P>
<P class=MsoNormal>Each of data type specifiers (TEXT, INT, FLOAT, DATE) has the same priority as NOT.</P>
<P class=MsoNormal>In the TEXT context, all patterns are considered as string values.</P>
<P class=MsoNormal>In the INT or FLOAT context, each pattern which represents a correct numeric constant is compared as a number, otherwise as text. E.g. <STRONG>"123"</STRONG> and <STRONG>\123</STRONG> aren't correct constants, so they will be compared as string values.</P>
<P class=MsoNormal>In the case of multi-variable search syntax, the common implicit field data type is automatically detected from variables.&nbsp;For example,&nbsp;if dates are mixed with non-dates (or texts mixed with non-texts), then&nbsp;the date type&nbsp;will be TEXT; when INT is mixed with FLOAT, then the date type will be FLOAT. Booleans are considered as INTs (0 or 1). Automatic types are only used if there are no explicit type specifiers.</P>
<P class=MsoNormal>Colons can be used to change the priority of NOT and specifiers, e.g. <STRONG>INT: &gt;=1 &lt;=10</STRONG> sets the integer type for the whole expression. Without the colon, INT would have&nbsp;operated only on&nbsp;<STRONG>&gt;=1</STRONG>.</P>
<P class=MsoNormal>Such "colon-attached" specifiers as AND: and OR: (&amp;: |:) set spaces as the implicit AND or the implicit OR. For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>OR: a b c (&amp;: d e f)</STRONG> is equivalent to <STRONG>a | B | c | d &amp; e &amp; f</STRONG>.</P>
<P class=MsoNormal>By default AND is the implicit operator.</P>
<P class=MsoNormal>The full list of "colon-attached" specifiers (no space before&nbsp;the colon):</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>TEXT: INT: FLOAT: DATE: AND: OR: NOT: &amp;: |: !:</STRONG></P>
<P class=MsoNormal>Data type specifiers and bindings are applied directly to positive patterns inside the linked expression. A data type specifier or binding just sets the scope. Units which a type/binding act on are only positive patterns. For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>TEXT ( !1 &amp; (200 | 300) ) is actually processed as !&nbsp;TEXT 1 &amp; (TEXT 200 | TEXT 300)</STRONG></P>
<P class=MsoNormal>It would be similar if there had been a single-variable or multi-variable binding in place of TEXT.</P>
<P class=MsoNormal>Data types operate the same between () and {}, so you can write {INT 1 &amp; TEXT a}. However, for bindings each {...} is considered a large atomic positive pattern.</P>
<P align=center><A href="#top">- Back to top -</A></P>
<H4><A id=Colon name=Colon></A>Colon-attached specifiers and variables</H4>
<P class=MsoNormal>Consider <STRONG>INT( &gt;=1 &lt;=10 )</STRONG>. The parentheses are required because INT has the same priority as NOT. Without them, INT would only affect <STRONG>&gt;=1</STRONG>, the whole expression being equivalent to <STRONG>INT( &gt;=1 ) &lt;=10</STRONG>.</P>
<P class=MsoNormal>INT: has the lowest priority.&nbsp;It is&nbsp;processed after NOT, AND and OR. Thus, <STRONG>INT: &gt;=1 &lt;=10</STRONG> is the same as <STRONG>INT: (&gt;=1 &lt;=10)</STRONG>. Owing to the colon, you can omit parentheses, making the expression simpler.</P>
<P class=MsoNormal>All the colon-attached specifiers have the same lowest priority. They are especially convenient when you apply them to the whole condition. However, when applying to simple operands (e.g. to terms containing patterns and comparisons), colon-attached specifiers may be unnecessary. For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>(INT: 100) | (TEXT: abc)</STRONG> is equivalent to a much simpler <STRONG>INT 100 | TEXT abc</STRONG></P>
<P class=MsoNormal>Because of their lowest priority and for the sake of avoiding ambiguities, all the colon-attached specifiers have to be used one by one on the left of the subsequent expression. They are placed at the very beginning of the whole condition or between "(" and the expression. The scope of such specifiers extend to the end of the condition or up to the corresponding ")". For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>Comment: 1:: "Document number": 2:: 123 &amp; abc</STRONG></P>
<P class=MsoNormal>has four specifiers followed by&nbsp;the syntax expression, <STRONG>123 &amp; abc</STRONG>.&nbsp;In the&nbsp;case of several colon-attached variables before the same syntax expression, all variables are implicitly grouped in a single binding with | between variable names. All the colon-attached configurations are similarly grouped in their own binding. The order of names/IDs/variables/configurations is not important.</P>
<P class=MsoNormal>&nbsp;</P>
<P class=MsoNormal align=center><A href="#top">- Back to top -</A></P>
<H6>Advanced Syntax - Details</H6>
<H4><A id=Advanced name=Advanced></A>Advanced specifiers (@:)</H4>
<P class=MsoNormal>Single-value search logic is the default search logic (see the <STRONG>Basic Syntax - Details</STRONG>&nbsp;section.) In some cases, multi-value search logic is needed. In multi-value search logic, conditions target multiple variables/configurations. To turn on multi-value search logic, you must use either the multi-value specifier, <STRONG>:</STRONG>, or the advanced specifier, <STRONG>@:</STRONG>. Advanced specifiers allow you to&nbsp;use variable/configuration names/identifiers inside conditions. They also turn on syntax checking and reporting. To turn on&nbsp;multi-value search logic&nbsp;and syntax checking, a condition must begin with @:. Because @ has a special meaning, it should be quoted or escaped if it is being searched for in patterns. The&nbsp;advanced specifier&nbsp;forces you to&nbsp;write safer and less ambiguous expressions. It forbids risky syntax elements such as inch (")&nbsp;constants. For example,&nbsp;it requires you to use <STRONG>4\"</STRONG> instead of <STRONG>4"</STRONG>. With the advanced specifier, you must use {} to specify local single-value complex patterns within multi-value conditions (see&nbsp;<A href="#Encapsulated">Encapsulated expressions and complex patterns</A>).</P>
<H4><A id=multi-value name=multi-value></A>Multi-value specifiers (:)</H4>
<P class=MsoNormal>The multi-value specifier (:) is a light version of the advanced specifier (@:). Like @:, the multi-value specifier (:) placed before a condition turns on multi-value search logic and indicates that you must use {} to specify local single-value complex patterns within multi-value condition.&nbsp;Unlike @:, the multi-value specifier (:) does not allow explicit variables/configurations&nbsp;and does not support&nbsp;syntax error messaging. For example,</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp; <STRONG>A B</STRONG> is equivalent to <STRONG>:{A B}</STRONG></P>
<P class=MsoNormal><STRONG>&nbsp;&nbsp;&nbsp; : {=5 =10}</STRONG> returns no documents</P>
<P class=MsoNormal>If you want a document with 5 in one variable/configuration and 10 in another variable/configuration, use:</P>
<P class=MsoNormal><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;: =5 =10</STRONG></P>
<P class=MsoNormal>To check whether a value&nbsp;is in a range, curly braces should be applied:</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp; <STRONG>:{&gt;=1 &lt;=10}</STRONG></P>
<P class=MsoNormal>Braces are not necessary for ranges&nbsp;if there is no multi-value specifier:</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp; <STRONG>&gt;=1 &lt;=10&nbsp;</STRONG></P>
<H4><A id=Bindings name=Bindings></A>Variable and configuration bindings</H4>
<P class=MsoNormal>@&nbsp; is called "variable binder", because it&nbsp;binds a variable to a pattern or representation.&nbsp;It indicates that the subsequent pattern represents a variable name or identifier (if a numeric constant). For example, <STRONG>@Comment</STRONG>, <STRONG>@"Document number"</STRONG>. A combination of a variable binder and a pattern is a binding.&nbsp;The binding&nbsp;has the same priority as DATE or NOT.&nbsp;The binding&nbsp;acts on the subsequent operand, i.e., it indicates that&nbsp;it needs to be compared with the given variable, e.g. <STRONG>@Number=100</STRONG>, <STRONG>@Author Johns.</STRONG></P>
<P class=MsoNormal>A binding can contain multiple variables. For example,&nbsp;<STRONG>@(Comment | "Document number") 123</STRONG> which&nbsp;is equivalent to <STRONG>@Comment 123 | @"Document number" 123</STRONG>. We can also use the other logical operators inside a binding. For example,&nbsp;<STRONG>@(V &amp; !U) P</STRONG> is the same as <STRONG>@V(P) &amp; !@U(P)</STRONG>. Multi-variable bindings provide better performance&nbsp;when compared to&nbsp;equivalent expressions where all bindings are single-variable ones.</P>
<P class=MsoNormal>If a variable name begins with an underscore, then it should be quoted/escaped, e.g. <STRONG>@"_SpecialVar"</STRONG>. Initial-underscore names are reserved for future syntax extensions. Currently only _Name has a special meaning in the syntax. _Name is a virtual variable indicating&nbsp;the file/folder name&nbsp;of a searched document/project. _Name can be used in any place where common variable names&nbsp;are used. _Name and _name are equivalent.</P>
<P class=MsoNormal>An empty string "" or numeric constant 0 represents one or more "virtual" variables. It can be used to specify&nbsp;the whole set of the database variables. <STRONG>@""</STRONG> is like <STRONG>@(var1 | var2 | ... | varN)</STRONG> which enumerates all of the common variable names. <STRONG>@("" | _Name)</STRONG> includes file/folder names in that enumeration.</P>
<P class=MsoNormal>A configuration binder @@ is similar to @ but deals with names and IDs of configurations. Again, <STRONG>@@0</STRONG> or <STRONG>@""</STRONG> searches over all configurations (and is assumed implicitly). Configuration 1 is present in projects and non-SOLIDWORKS documents and has a predefined name " ", i.e. a single space. Configuration 2 (commonly named "@") represents&nbsp;the default configuration.</P>
<P class=MsoNormal>@() and @@() set the initial (default) binding state: @() indicates that no variables are defined, so they should be explicitly present in the subsequent sub-formula. @@() is the same as @@0 and indicates that all configurations are searched.</P>
<P class=MsoNormal>You can think of data type specifiers and bindings as applied directly to positive patterns inside linked expressions. A data type specifier or binding just sets the scope. Units that a type/binding acts on are positive patterns.</P>
<P class=MsoNormal>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>@(var1|var2) (&gt;=100 !150 &lt;=200)</STRONG> is equivalent to <STRONG>@(var1|var2) {&gt;=100 &lt;=200} &amp; !@(var1|var2) 150</STRONG>.</P>
<H4><A id=Colon2 name=Colon2></A>Colon-attached bindings</H4>
<P>Bindings can be set in the "colon-attached" format. For example,</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>Comment: 1:: "Document number": 2:: 123 &amp; abc</STRONG> is the same as <STRONG>@(Comment | "Document number") @@(1|2) (123 &amp; abc)</STRONG></P>
<P>Configuration bindings use colons to differentiate them from variable bindings.</P>
<P>@ and @@ are not applied at all if colons are used.</P>
<P>&nbsp;</P>
<P align=center><A href="#top">- Back to top -</A></P>
            <a name="seealsobookmark"></a>
            
        </div>
        
        <div id="pagefooter">
            
        </div>
        
    </div>
    
</body>
</html>